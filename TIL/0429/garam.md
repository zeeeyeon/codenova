
# 2025.04.22(화)

### KPT 작성

#### `Keep` : 현재 만족하고 있는 부분, 계속 이어갔으면 하는 부분
- 프론트 UI 아주 완벽합니다
- 배포 서버가 아주 빠르게 띄워져서 좋습니다
- 의견 소통 자유로워서 좋습니다 

#### `Problem` : 불편하게 느끼는 부분, 개선이 필요하다고 생각되는 부분
- 브로드캐스트나 응답 보낼 때 필요한 데이터를 안보내는 경우가 종종 있음
- 포스트맨으로만 확인을 하고 테스트를 해봤는데 이제 클라이언트에서 이벤트를 호출 하면서 테스트를 하니까 생각 못한 에러가 발생함
- 코드 DB에 저장할 언어별 코드 데이터를 양질의 데이터를 긁어 모아서 저장하는게 좋다고 생각함. 


#### `Try` : problem에 대한 해결책, 다음 회고 때 판별 가능한 것, 당장 실행 가능한 것
- 소켓 이벤트는 다 만들었으니 나도 웹사이트 들어가서 지인이가 소켓 연결하고 이벤트 송수신 해놓은거 확인해보면서 어떤 에러 발생하는지 확인하고 바로바로 수정해주기
- 크롤링으로 하는거 보단 gpt나 클로드 활용해서 양질의 코드 생성해달라고 하고 형식만 바꿔서 DB에 저장하기 


---
#### `Today`
- gameRoom에서 플레이어 관리, 게임 상태 관리, 단어 관리, 점수 관리를 해주는데 여기서 동시성 처리가 안되있어서 자바 내장 키워드인 synchronized를 사용해서 동기화를 해주는 코드를 작성

- 목적별로 분리해서 락 객체를 추가한 후 각각의 락 객체를 사용하여 목적별로 락을 걸어 서로 관련
없는 연산들이 서로 블로킹하지 않도록 처리 

```java
public class GameRoom {
    private final Object lockPlayer = new Object();
    private final Object lockGame = new Object();
    private final Object lockWord = new Object();
    private final Object lockScore = new Object();

    // 단어 관리 메서드
    public void addActiveWord(String word) {
        synchronized(wordLock) {
            activeFallingWords.add(word);
        }
    }

    // ...
}

// 이렇게 락 객체를 추가 해주고 메서드에 관련있는 락 객체를 사용하여 락을 걸어줌

```

- 게임 시작시 바로 게임 시작 이벤트 전송 하고 그 후의 로직이 실행되게 해놨는데 그러면 프론트쪽에서 바로 처리하는게 어렵기 때문에 서버에서 3초후 게임 시작 이벤트 전송하고 그 후 로직 실행되도록 수정 
- 처음에는 Thread.sleep()을 사용하였는데 이는 Netty IO 쓰레드를 블로킹해버려서 서버 전체가 멈춘것 같은 현상이 발생해 다른 클라이언트가 이벤트를 보내는데 영향을 줄 수 있었지만,  taskScheduler를 사용하여 Netty IO 쓰레드를 블로킹 하지 않아 다른 클라이언트 연결,이벤트에 영향을 안줌

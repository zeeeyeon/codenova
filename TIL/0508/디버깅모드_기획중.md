싸피의 커리큘럼 

1. List1
 - 배역
 - 정렬
 - 부분집합
 - 검색
 - 이진 검색 인덱스 

3. String
 - 문자열
 - 패턴 매칭
 - KMP 알고리즘
 - 보이어 무어 알고리즘
 - 문자열 암호화
 
4. Stack1
 - 스택
 - 재귀 호출
 - memoization
 - DP
 - DFS
5. Stack2
 - 계산기
 - 백트래킹
 - 부분집합
 - 순열
 - 가지치기
 
6. Queue
 - 큐 
 - 원형 큐
 - 연결 큐 및 우선순위 큐 및 버퍼
 - BFS

응용
7. Tree
 - 트리
 - 이진트리
 - 순회
 - 이진트리 표현
 - 이진트리 탐색
 - 힙

8. Start
- 복잡도 분석
 - 표준 입출력 및 진수 (진법)
 - 진법 변환 
 - 비트 연산
 - 실수
 
9. 완전 검색/ 탐욕 알고리즘
 - 반복과 재귀
 - 순열
 - 완전 탐색
 - 부분 집합
 - 조합
 - Greedy

10. 분할정복 이진검색
 - 분할 정복
 - 병합 정렬
 - 퀵정렬
 - 이진 검색

 

11. 백트래킹 응용 / 그래픽(트리)
 - 백트래킹 응용
 - 트리 개요
 - 이진 트리
 - BST(이진탐색 트리) 및 힙 트리(Heap Tree)

12. 그래프
 - 그래프 기본
 - DFS
 - BFS
 - Union-Find(Disjoint set)
 - 최소 비용 신장 트리(MST)
 - Prim 알고리즘
 - Kruskal 알고리즘
 - 최단 경로 (Dijkstra)


학습자가 점진적을 쌓을 수 있도록 **기본 알고리즘 학슴 -> 응용 -> 탐색/트리/그래프 확장의 흐름**으로 구성되어있음
여기에 우리 서비스에 맞춰 중복 요소 제거나 단계별로 정리를 하면서 우리 서비스의 커리큘럼을 개발
- 부분집합, 순열, 백트래킹, DFS가 여러 단원에 중복되어 있었는데 이를 완전탐색 챕터에서 집중적으로 정리
- Start 챕터의 진법, 실수, 비트연산은 시뮬레이션/기초 수학 모듈로 따로 묶거나 입출력/기초 연산 챕터로 초기 설정

- 추후 백준 사이트의 문제와도 매칭을 시켜볼 수 있을거 같음


## 1.List & 기본 탐색
- 리스트 순회 & 정렬
- 순열 / 조합 / 부분집합 (기본 개념)
- 선형 탐색 / 이진 탐색
- 인덱스 활용
- 슬라이딩 윈도우 / 투 포인터

### 코드 예시 목록
1. 리스트 순회	     
 - 기본 for문 순회, 합 구하기	
 - arr = [1,2,3]; total = sum(arr)
2. 최댓값/최솟값 찾기	
 - 단순 탐색	
 - max_value = max(arr)
3. 값 존재 여부 확인	
 - in 키워드 사용 or 직접 순회	
 - if target in arr:
4. 버블 정렬	
 - 반복문으로 구현하는 기초 정렬	
 - for i in range(len(arr)):
5. 선택 정렬	
 - 최소값을 앞으로 가져오는 방식	
 - min_idx = ...
6. 선형 탐색	
 - 원하는 값 찾기	
 - for i in arr:
7. 이진 탐색 (반복/재귀)	
 - 정렬된 리스트에서의 탐색	
 - mid = (start + end)//2
8. 투 포인터 기초	
 - 두 합이 특정 값 되는 쌍 찾기	
 - left, right = 0, len(arr)-1
9. 슬라이딩 윈도우	
 - 고정 길이의 연속 구간 합	
 - window_sum = sum(arr[i:i+k])
10. 리스트 컴프리헨션	
 - Python 문법 익히기	
 - [x for x in arr if x > 0]

## 2.문자열 알고리즘
- 문자열 조작
- 패턴 매칭 (Brute-force)
- KMP 알고리즘
- 보이어-무어
- 문자열 해싱 / 암호화 기초

### 코드 예시 목록
1. 문자열 조작	
 - 기본 슬라이싱, replace, split 등	
 - s = "hello world"; s[:5], s.replace(" ", "-")
2. 패턴 매칭 (Brute-force)	
 - 일일이 한 칸씩 이동하며 매칭 시도	
 - 두 포인터 시각화 (i, j 위치 강조)
3. KMP 알고리즘	
 - 실패 함수(next 배열)로 점프	
 - 실패 함수 생성 시각화 + 비교 줄이기
4. 보이어-무어 알고리즘	
 - 마지막 문자 먼저 비교, 점프 테이블 활용	
 - 문자 테이블 구성, 점프 거리 시각화
5. 문자열 해싱 기초	
 - 아스키 값과 진법 기반 해싱	
 - ord(), rolling hash, 충돌 예시
6. 암호화 기초	
 - 시저 암호, 아스키 코드 활용	
 - chr(ord(c) + 3)

## 3.Stack & 재귀
- Stack 기본 / 후위표기 계산기
- 재귀 호출 & 기저 조건
- Memoization / DP 기초
- DFS 기초 (재귀 + 스택 기반)

### 코드예시 목록
1. Stack 기본	
 - push, pop, top, isEmpty	
 - stack.append() / stack.pop()
2. 후위표기 계산기	
 - 연산자 스택 이용	
 - 2 3 + → 5
3. 재귀 함수 이해	
 - 콜스택 흐름 시각화	
 - 팩토리얼, 피보나치
4. 기저 조건	
 - 재귀 탈출 조건	
 - if n == 0: return 1
5. Memoization	
 - 재귀 + 캐시	
 - 피보나치 with cache
6. DFS (재귀/스택)	
 - 그래프 탐색	
 - 인접 리스트 기반 탐색

## 4.Queue & BFS
- Queue / Deque / 원형 큐
- 우선순위 큐 (heapq)
- BFS (큐 기반 구현)
- 최단 거리 탐색 (unweighted graph)

### 코드 예시 목록
1. 기본 큐 / 덱
 - FIFO 구조
 - 큐의 양쪽 push/pop
2. 원형 큐	
 - front/rear 순환	
 - 인덱스 원형 이동 애니메이션
3. 우선순위 큐	
 - 힙을 통한 자동 정렬	
 - push 후 정렬 모습 강조
4. BFS	
 - 큐 기반 탐색 흐름	
 - 큐, 방문 순서, 그래프 노드 표시
5. 최단 거리	
 - 거리 계산 (BFS)	
 - 노드에 거리 숫자 표기, 점점 칠해짐


## 5.완전 탐색 & 백트래킹
- 순열 / 조합 / 부분집합 (재귀형)
- 가지치기 / visited 배열
- N-Queen / 암호 만들기
- 백트래킹 vs 완전탐색 비교

## 코드 예시 목록
1. 순열 / 조합 / 부분집합	
 - 재귀 호출 구조, 선택 분기 흐름 이해	
 - 트리 형태의 호출 흐름, 선택된 path 실시간 표시
2. visited / 가지치기	
 - 방문 체크 및 백트래킹 구조 체험	
 - visited 배열 변화, 분기 후 복귀(backtrack) 애니메이션
3. N-Queen 문제	
 - 조건 기반 유효성 판단과 체스판 배치 논리 이해	
 - 체스판 시각화, 유효 위치 체크, 잘못된 배치 되돌리기
4. 조건형 백트래킹 (암호 생성)	
 - 조합 중 조건 충족 시에만 출력하는 분기 처리	
 - 모음/자음 조건 체크, 조건 만족/실패 상태 표시
5. 완전탐색 vs 백트래킹 비교	
 - 시간 복잡도 차이, 불필요한 탐색 줄이기 체감	
 - 탐색 트리 비교 시각화 (중간 가지 자르는 애니메이션)


## 6.정렬 & 분할정복
- 기본 정렬: 선택/삽입/버블
- 고급 정렬: 퀵 / 병합 정렬
- 분할 정복 개념
- 이진 탐색 응용 (parametric search)

## 코드 예시 목록
1. 기본 정렬 (선택 / 삽입 / 버블)	
 - 비교와 교환의 반복 원리 이해, 정렬 시간 복잡도 체감	
 - 인접 요소 간 비교/교환 흐름 애니메이션, 선택 위치 강조
2. 고급 정렬 (퀵 / 병합 정렬)	
 - 분할 → 정복 흐름 이해, 재귀 기반 정렬 방식의 차이점	
 - 퀵: 피벗 기준 좌우 분할, 병합: 병합 과정 시 리스트 정렬 상태 변화 시각화
3. 분할 정복 개념	
 - 문제를 나누고 해결한 뒤 병합하는 사고 방식 학습	
 - 호출 트리 구조 애니메이션, 문제 분할과 재귀 호출 시각화
4. 이진 탐색 응용 (Parametric Search)	
 - 조건을 만족하는 최적의 값 찾기, 범위를 줄여가며 답 도출	
 - left, right, mid 포인터 이동 애니메이션, 정답 가능 구간 색상 변화


## 7.트리 & 이진 트리
- 트리 기본 구조 및 순회
- 이진 탐색 트리 (BST)
- 힙 / 우선순위 트리
- 트리에서의 DFS / 백트래킹

### 코드 예시 목록
1. 트리 기본 구조 및 순회	
 - 트리의 계층 구조, 노드 간 관계, 전위/중위/후위 순회 방식 이해	
 - 트리 노드 연결 구조 시각화, 순회 순서 따라 노드에 색상 변화
2. 이진 탐색 트리 (BST)	
 - 정렬된 이진 트리의 삽입/탐색 원리 이해, 왼쪽 < 부모 < 오른쪽 구조 체득	
 - 삽입 과정 애니메이션, 탐색 시 비교 흐름 시각화
3. 힙 / 우선순위 트리	
 - 힙의 삽입/삭제 구조, 우선순위 큐에서의 사용법	
 - 배열 기반 힙 구조 → 트리 구조로 변환 애니메이션, 힙 정렬 흐름
4. 트리에서의 DFS / 백트래킹	
 - 트리 구조에서의 깊이 우선 탐색 및 분기/복귀 흐름 이해	
 - DFS 분기 → 방문 → 복귀 흐름 트리로 시각화, 노드 방문 순서 강조


## 8.그래프 이론
- 인접 행렬 / 리스트
- DFS / BFS
- Union-Find
- 사이클 판별 / 위상 정렬

### 코드 예시 목록
1. 인접 행렬 / 리스트	
 - 그래프 표현 방식의 차이, 노드 간 연결 관계를 데이터로 나타내는 방식 이해	
 - 행렬 및 리스트 구조 비교 시각화, 노드 간 간선 연결 그림으로 표현
2. DFS / BFS	
 - 그래프에서의 깊이/너비 우선 탐색 방식 이해, 재귀 vs 큐 기반 구조 비교	
 - 노드 방문 순서 애니메이션, DFS는 분기 깊이, BFS는 레벨 순으로 칠하기
3. Union-Find	
 - 노드 간 집합 표현 방식, 경로 압축 및 union 연산 이해	
 - 트리 구조의 집합 병합 시각화, find 시 경로 압축 변화 강조
4. 사이클 판별 / 위상 정렬	
 - 방향/비방향 그래프에서의 사이클 판별, 진입 차수 기반 위상 정렬 개념 이해	
 - 위상 정렬 순서대로 노드가 사라지는 애니메이션, 사이클 감지 시 붉은 경로 표시


## 9.최단 경로 & MST
- Dijkstra (우선순위 큐 기반)
- Bellman-Ford
- Floyd-Warshall
- Kruskal / Prim (MST)

## 코드 예시 목록
1. Dijkstra (우선순위 큐 기반)	
 - 우선순위 큐를 이용한 최단 거리 탐색, 방문한 노드부터 거리 업데이트	
 - 현재 노드, 큐 상태, 거리 테이블을 실시간으로 보여주며 색상으로 경로 확정 표시
2. Bellman-Ford	
 - 음수 간선이 포함된 그래프에서 거리 갱신 반복, 음수 사이클 탐지 방법	
 - 모든 간선을 반복적으로 순회하며 거리 테이블 변화 시각화, 음수 사이클 감지 강조
3. Floyd-Warshall	
 - 모든 쌍 최단 거리 계산, 중간 노드를 거쳐가는 방식 이해	
 - 2차원 거리 테이블 변화 과정을 단계별로 업데이트하며 시각적으로 보여줌
4. Kruskal / Prim (MST)	
 - 최소 비용 신장 트리 구성, 간선 중심(Kruskal)과 노드 중심(Prim)의 차이 이해	
 - 간선 선택 순서 애니메이션, 트리에 추가되는 간선을 색상 변화로 강조


## 10 동적계획법 고급
- Top-down / Bottom-up 비교
- 배낭 문제
- LIS (가장 긴 증가하는 부분 수열)
- DP + 그래프

### 코드 목록 예시
1. Top-down / Bottom-up 비교	
 - 재귀 기반의 Memoization vs 반복문 기반의 DP 차이 이해	
 - 호출 순서 트리 vs 테이블 채워지는 순서 비교, 캐시 사용 여부 강조
2. 배낭 문제 (0/1 Knapsack)	
 - 상태 정의, 물건 선택 여부에 따른 최적 가치 계산	
 - 아이템 선택 여부에 따른 테이블 업데이트 애니메이션, 최적 경로 색상 표시
3. LIS (가장 긴 증가하는 부분 수열)	
 - DP 배열의 상태 변화, 증가하는 수열 조건 이해	
 - 각 인덱스의 DP 값 증가 흐름, 수열 선택 경로 애니메이션
4. DP + 그래프	
 - 그래프에서 최적 경로 또는 경우의 수를 DP로 해결하는 방식 이해	
 - 노드별 DP 값 표시, 그래프 경로 따라 전이되는 DP 상태 변화 시각화
